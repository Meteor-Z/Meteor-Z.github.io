<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Skills on Meteor-Z个人播客</title><link>https://liuzechen.top/skill/</link><description>Recent content in Skills on Meteor-Z个人播客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 21 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://liuzechen.top/skill/index.xml" rel="self" type="application/rss+xml"/><item><title>事件传递与响应</title><link>https://liuzechen.top/skill/2025-07-21-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94/</link><pubDate>Mon, 21 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-21-%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E4%B8%8E%E5%93%8D%E5%BA%94/</guid><description>今天居然是0721诶
第一响应者 事件传递的过程 触发事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中； UIApplication 会从事件队列中取出最前面的事件，将之分发出去以便处理，通常，先发送事件给应用程序的主窗口（ keyWindow ）； 主窗口会在视图层次结构中找到一个最适合的视图来处理触摸事件； 找到适合的视图控件后，就会调用该视图控件的 touches(_:with:) 方法； touches(_:with:) 的默认实现是将事件顺着响应者链一直传递下去，直到连 UIApplication 对象也不能响应事件，则将其丢弃。 查找过程 iOS采用hit-test的形式进行遍历
hit-test采用逆序深度遍历的方式找到最前面的视图，然后这个视图 响应者链 当事件发生之后，从触发事件的源头开始，按照一定的顺序对各个视图或者空间进行遍历处理，直到最终被处理或者被丢弃，
传递到下面后，然后往上开始回溯，找到第一个响应者，如果这个响应者不处理，就会通过nextResponder往上走，直到有事件响应。
这个第一响应者就是当前页面要处理消息的第一个Button/Text等，比如说说一个文本框，如果让文本框成为第一响应者，那么他就会弹出来，让用户输入</description></item><item><title>masonry使用小结</title><link>https://liuzechen.top/skill/2025-07-20-masonry%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</link><pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-20-masonry%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</guid><description>这周我开始使用了masonry，对于frame布局来说，很多地方确实不错，以下是开发的时候使用小结
多个View中间有间隔，并且想要居中 其实可以用一个parentView，将这些View放到parentView里面，然后让其&amp;quot;撑开&amp;quot;,然后对parentView实现居中即可。
[]</description></item><item><title>Xcode使用技巧</title><link>https://liuzechen.top/skill/2025-07-16-xcode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link><pubDate>Wed, 16 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-16-xcode%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid><description>常用命令 cmd + shift + j # 在文件中，直接定位到左边的目录 cmd + shift + o # 快速打卡某一个文件 cmd + control + shift + a # 打开git，找凶手</description></item><item><title>ARM汇编</title><link>https://liuzechen.top/skill/2025-07-10-arm%E6%B1%87%E7%BC%96/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-10-arm%E6%B1%87%E7%BC%96/</guid><description>寄存器 ARM一共有33个寄存器，0-30是通用寄存器，31和32是专用寄存器（31是sp寄存器，32是pc寄存器），所以是31个通用寄存器，两个特殊寄存器，当然，还有几个是状态寄存器，
前31个寄存器的访问方式是：
使用X0～X30来访问时，是64位数据 使用W0～W30访问时，是低32位的数据 对于特殊寄存器来说：
32bit的时候，作为栈帧寄存器（stack point,SP）的时候，用WSP来访问 64bit的时候，作为栈帧寄存器（stack point,SP）的时候，用SP来访问 32bit的时候，作为零寄存器（Zero register）的时候，用WZR来访问 64bit的时候，作为零寄存器（Zero register）的时候，用WZ来访问 常用寄存器如下：
X0 ~X7：传递函数的参数，如果有更多参数，则通过栈来传递 X0： 既可以当参数的返回值，又可以当参数的传递 这里的X0，X1可以直接跟msg_Send一样绑定，第一个参数是self，第二个参数是选择子，第三个参数之后就是真正的参数。 SP，上述的栈指针寄存器，维护栈指针，指向栈的顶端。 FP（Frame Point），X29，栈指针寄存器，指向栈的底部 LR （Link Register）X30，链接寄存器，存储的是函数调用完成的返回地址 函数栈为什么知道这个，就是使用LR指针。 PC（Programe Counter）: 程序寄存器，表示的是程序的下一行地址的位置。 X19寄存器：i0S中有很多self这样的标识自身，这个地址就是放在X19上 常用指令 SVC：调一个系统调用 函数 X0-X7放函数的参数， X0作为函数的返回值，如果是结构体的话，那么就将用X8兼容一下 X19基本都是self,基本调一下 函数跳转</description></item><item><title>iOS调试</title><link>https://liuzechen.top/skill/2025-07-09-ios%E8%B0%83%E8%AF%95/</link><pubDate>Wed, 09 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-09-ios%E8%B0%83%E8%AF%95/</guid><description>符号调试 在Xcode设置符号断点即可。
如何看某一个数值被XXX更改了，然后看回溯栈？ 使用KVO进行注册，然后监控即可</description></item><item><title>iOS视图</title><link>https://liuzechen.top/skill/2025-07-08-ios%E8%A7%86%E5%9B%BE/</link><pubDate>Tue, 08 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-08-ios%E8%A7%86%E5%9B%BE/</guid><description>视图更新位置 写视图的方式千千万万，那么哪一种是最为规范的呢？
在initWithFrame中处理视图的层级，比如说addSubview等，然后处理self相关的，比如说设置背景等 在updateConstraints中更新autolayout视图，用到的View在init中全部加入，如果有的View用不到的话，直接hidden就好了。 setNeedsLayout VS layoutIfNeded setNeedsLayout会调用layoutSubViews方法，对于子视图进行重新布局 限频？ setNeedsDisplay setNeedsDisplay是异步执行的，自动调用drawRect:方法 什么时候需要在 iOS 中调用 setNeedsDisplay？ 就是覆盖了drawRect的时候，才需要这个方法，日常的UI界面已经涵盖了这个方法了，就是已经帮你实现了drawRect了，不需要重写了</description></item><item><title>iOS核心动画高级技巧</title><link>https://liuzechen.top/skill/2025-07-06-ios%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 06 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-06-ios%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</guid><description>UIView和CALayer CALayer是图层，仅仅是显示UI界面的，但是UIView包含的东西非常多，而且UIView的性能其实没有显示的性能影响，使用图层关联的视图而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理。
layer专门显示动画，绘图，因为macOS和iOS的绘图原理是相同的，但是接触方式是不同的（一个是鼠标点击，一个是触摸），所以这里将其分开，分别维护。比如说CGColorRef为什么有这个，是因为layer是QuartzCore框架，不是UIKit框架里面的。
UIButton的继承：UIButton -&amp;gt; UIControl -&amp;gt; UIView -&amp;gt; UIResponder UUIControl是将复杂的触摸事件封装成了简单的易于使用的控件事件
什么时候使用CALayer而不是UIView mac OS上运行的跨平台程序 使用CALayer的子类 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图） 但是我觉得还是用UIView可能更加方便，因为视图和视图之间可能要添加，UIView可以很高的添加上去。
使用小结 transform transform伸缩变化的过程中，其实是对anchorPoint开始，然后开始伸缩变化，但是很多时候我想要将某一个组件从左到右开始伸缩，</description></item><item><title>Effective-Objective-C总结</title><link>https://liuzechen.top/skill/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 10 May 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</guid><description>书是挺好的，但是翻译有的时候翻译真的有点烂，这里写一下我学习过程中，对例子解析一下。
6 了解属性的概念 这里引出OC和C++是不一样的，C++是使用offset的形式找到对应的数据变量，但是这样可能因为在不同的DLL导致起定义出错而crash，OC中将实例变量交给类对象管理，然后在运行期查找，不直接在编译期确定，可以避免上述的crash。甚至可以在运行期加入成员。
7 在对象内部尽量直接访问实例变量 我写代码的时候，经常有以下问题，一段代码中可以使用self.xxx或者_xxx进行访问，其中使用self.xxx可以使用懒加载，但是这里好像更推荐使用直接访问实例变量，也就是_xx这样，原因如下：
不会触发信息派发，那么就不会走msg_Send那一套，那么速度就会快一些 如果直接访问实例变量，那么就不会触发KVO（也就是键值观察）？ 但是有时候可能使用懒加载，那么这时候可能就需要self.xxxx了，所以就有一个折中，如果是在写入的话，那么就通过设置方法self.xxx来做，如果是读取，那么就直接访问。 12 理解动态转发 这篇讲得不错，其中的代码样例。
先看自己能不能解决，往自己对象里面加入方法，然后再跑一遍消息转发 自己不能解决，就让别的对象解决，看其他对象能不能能处理，比如说这个self的一些子类可能会处理这个self的方法 forwardingInvocation直接兜底，要么吃掉，要么转发其他对象，要么换成其他消息，如果怎么都不行最后直接doesNotRecognizeSelector报错。 17 实现description方法 顾名思义，主要是用于调试用的，在NSLog等控制台中进行调试，
带上对象的地址 带上对象的属性 这里有一点，NSLog如果打印一个对象的话，那么调用的就是description方法，所以如果在description方法里面调用NSLog的话，那么就会发生死递归，这里要特别注意一下。</description></item><item><title>iOS Runtime</title><link>https://liuzechen.top/skill/2025-03-24-oc-runtime/</link><pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-03-24-oc-runtime/</guid><description>之前学了一下Objective-C的Runtime,发现学的不是那么深刻，所以这里写一篇文章，算是边写边学了。
概念 OC中加入了很多新的概念，其中主要好似有instace object和class object和meta object，主要是有以下区别，
instace object(实例对象)：instance示例对象是通过alloc出来的对象，每次使用alloc都会产生新的instance对象。 class对象(类对象)：对于每一个类，内存中有且只有一个类对象。 meta-class(元类对象)：对于每一个类来说，内存中有且只有一个类对象 这里说是对象，其实是因为oc everything is object，所以这里抽象成对象了，如果是C++，那么其实就是类，零成本抽象，其实没有那么多区别
对于上述对象中存储的东西，有以下区别。
实例对象（instance object） isa指针：指向的是类对象 对象中的成员变量 类对象（class object） isa指针：指向的是元类对象 superClass指针：指向的是他的父类，是类对象的父亲，如果到顶了，就是nil 类的属性信息（@property），类的对象方法信息（method &amp;lsquo;-&amp;lsquo;开头的方法）,类的协议信息（protocol）和类的成员变量信息（ivar）等。 元类（meta object） isa指针 superClass指针：指向他的父类，也就是元类对象的父亲，不同的是，如果到顶了，那么这里指向的是基类的class 类的方法信息（也就是+开头的方法） 以下是对象的相关关系
消息发送 OC中的调用方法是在Runtime运行期展开的，而不是像C/C++一样在编译期就确定了，所以与C++一样调到某一个地址就可以，大致的消息转发流程如下
先通过isa指针找到对应的类对象，或者是找到对应的meta-class 如如果是实例对象（instance object）调用，那么就找到对应的类对象（class object），如果是类方法调用，先找到对应的元对象（meta-class object） 如果当前找到了，那么就直接执行对应的方法就行了 如果没有找到，那么就通过类对象或者实例对象的superClass指针往上找，就是沿着他的父类找，一直往上找 如果最终找不到，那么就会Crash(当然，也会有补救错误) 这里有一点不同的是，注意到meta-class的superClass指针指向的是基类的类对象，那么这时候还是往基类的类对象找一下，调用一下，如果找不到，就crash。 补救方法 待补充</description></item></channel></rss>