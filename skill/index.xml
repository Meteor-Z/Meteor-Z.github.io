<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Skills on Meteor-Z个人播客</title><link>https://liuzechen.top/skill/</link><description>Recent content in Skills on Meteor-Z个人播客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 10 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://liuzechen.top/skill/index.xml" rel="self" type="application/rss+xml"/><item><title>ARM汇编</title><link>https://liuzechen.top/skill/2025-07-10-arm%E6%B1%87%E7%BC%96/</link><pubDate>Thu, 10 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-10-arm%E6%B1%87%E7%BC%96/</guid><description>常用指令 SVC：调一个系统调用 寻址 LDR W0, [X1]
函数 X0-X7放函数的参数， X0作为函数的返回值，如果是结构体的话，那么就将用X8兼容一下 X19基本都是self,基本调一下 函数跳转</description></item><item><title>iOS调试</title><link>https://liuzechen.top/skill/2025-07-09-ios%E8%B0%83%E8%AF%95/</link><pubDate>Wed, 09 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-09-ios%E8%B0%83%E8%AF%95/</guid><description>符号调试 在Xcode设置符号断点即可。
如何看某一个数值被XXX更改了，然后看回溯栈？ 使用KVO进行注册，然后监控即可</description></item><item><title>iOS视图</title><link>https://liuzechen.top/skill/2025-07-08-ios%E8%A7%86%E5%9B%BE/</link><pubDate>Tue, 08 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-08-ios%E8%A7%86%E5%9B%BE/</guid><description>setNeedsLayout VS layoutIfNeded setNeedsLayout会调用layoutSubViews方法，对于子视图进行重新布局 限频？ setNeedsDisplay setNeedsDisplay是异步执行的，自动调用drawRect:方法 什么时候需要在 iOS 中调用 setNeedsDisplay？ 就是覆盖了drawRect的时候，才需要这个方法，日常的UI界面已经涵盖了这个方法了，就是已经帮你实现了drawRect了，不需要重写了</description></item><item><title>iOS核心动画高级技巧</title><link>https://liuzechen.top/skill/2025-07-06-ios%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 06 Jul 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-07-06-ios%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</guid><description>UIView和CALayer CALayer是图层，仅仅是显示UI界面的，但是UIView包含的东西非常多，而且UIView的性能其实没有显示的性能影响，使用图层关联的视图而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理。
layer专门显示动画，绘图，因为macOS和iOS的绘图原理是相同的，但是接触方式是不同的（一个是鼠标点击，一个是触摸），所以这里将其分开，分别维护。比如说CGColorRef为什么有这个，是因为layer是QuartzCore框架，不是UIKit框架里面的。
UIButton的继承：UIButton -&amp;gt; UIControl -&amp;gt; UIView -&amp;gt; UIResponder UUIControl是将复杂的触摸事件封装成了简单的易于使用的控件事件
什么时候使用CALayer而不是UIView mac OS上运行的跨平台程序 使用CALayer的子类 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图） 但是我觉得还是用UIView可能更加方便，因为视图和视图之间可能要添加，UIView可以很高的添加上去。</description></item><item><title>Effective-Objective-C总结</title><link>https://liuzechen.top/skill/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 10 May 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</guid><description>书是挺好的，但是翻译有的时候翻译真的有点烂，这里写一下我学习过程中，对例子解析一下。
6 了解属性的概念 这里引出OC和C++是不一样的，C++是使用offset的形式找到对应的数据变量，但是这样可能因为在不同的DLL导致起定义出错而crash，OC中将实例变量交给类对象管理，然后在运行期查找，不直接在编译期确定，可以避免上述的crash。甚至可以在运行期加入成员。
7 在对象内部尽量直接访问实例变量 我写代码的时候，经常有以下问题，一段代码中可以使用self.xxx或者_xxx进行访问，其中使用self.xxx可以使用懒加载，但是这里好像更推荐使用直接访问实例变量，也就是_xx这样，原因如下：
不会触发信息派发，那么就不会走msg_Send那一套，那么速度就会快一些 如果直接访问实例变量，那么就不会触发KVO（也就是键值观察）？ 但是有时候可能使用懒加载，那么这时候可能就需要self.xxxx了，所以就有一个折中，如果是在写入的话，那么就通过设置方法self.xxx来做，如果是读取，那么就直接访问。 12 理解动态转发 这篇讲得不错，其中的代码样例。
先看自己能不能解决，往自己对象里面加入方法，然后再跑一遍消息转发 自己不能解决，就让别的对象解决，看其他对象能不能能处理，比如说这个self的一些子类可能会处理这个self的方法 forwardingInvocation直接兜底，要么吃掉，要么转发其他对象，要么换成其他消息，如果怎么都不行最后直接doesNotRecognizeSelector报错。 17 实现description方法 顾名思义，主要是用于调试用的，在NSLog等控制台中进行调试，
带上对象的地址 带上对象的属性 这里有一点，NSLog如果打印一个对象的话，那么调用的就是description方法，所以如果在description方法里面调用NSLog的话，那么就会发生死递归，这里要特别注意一下。</description></item><item><title>iOS Runtime</title><link>https://liuzechen.top/skill/2025-03-24-oc-runtime/</link><pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/skill/2025-03-24-oc-runtime/</guid><description>之前学了一下Objective-C的Runtime,发现学的不是那么深刻，所以这里写一篇文章，算是边写边学了。
概念 OC中加入了很多新的概念，其中主要好似有instace object和class object和meta object，主要是有以下区别，
instace object(实例对象)：instance示例对象是通过alloc出来的对象，每次使用alloc都会产生新的instance对象。 class对象(类对象)：对于每一个类，内存中有且只有一个类对象。 meta-class(元类对象)：对于每一个类来说，内存中有且只有一个类对象 这里说是对象，其实是因为oc everything is object，所以这里抽象成对象了，如果是C++，那么其实就是类，零成本抽象，其实没有那么多区别
对于上述对象中存储的东西，有以下区别。
实例对象（instance object） isa指针：指向的是类对象 对象中的成员变量 类对象（class object） isa指针：指向的是元类对象 superClass指针：指向的是他的父类，是类对象的父亲，如果到顶了，就是nil 类的属性信息（@property），类的对象方法信息（method &amp;lsquo;-&amp;lsquo;开头的方法）,类的协议信息（protocol）和类的成员变量信息（ivar）等。 元类（meta object） isa指针 superClass指针：指向他的父类，也就是元类对象的父亲，不同的是，如果到顶了，那么这里指向的是基类的class 类的方法信息（也就是+开头的方法） 以下是对象的相关关系
消息发送 OC中的调用方法是在Runtime运行期展开的，而不是像C/C++一样在编译期就确定了，所以与C++一样调到某一个地址就可以，大致的消息转发流程如下
先通过isa指针找到对应的类对象，或者是找到对应的meta-class 如如果是实例对象（instance object）调用，那么就找到对应的类对象（class object），如果是类方法调用，先找到对应的元对象（meta-class object） 如果当前找到了，那么就直接执行对应的方法就行了 如果没有找到，那么就通过类对象或者实例对象的superClass指针往上找，就是沿着他的父类找，一直往上找 如果最终找不到，那么就会Crash(当然，也会有补救错误) 这里有一点不同的是，注意到meta-class的superClass指针指向的是基类的类对象，那么这时候还是往基类的类对象找一下，调用一下，如果找不到，就crash。 补救方法 待补充</description></item></channel></rss>