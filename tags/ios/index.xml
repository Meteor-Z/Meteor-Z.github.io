<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iOS on Meteor-Z个人播客</title><link>https://liuzechen.top/tags/ios/</link><description>Recent content in iOS on Meteor-Z个人播客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 10 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://liuzechen.top/tags/ios/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective-Objective-C总结</title><link>https://liuzechen.top/work/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</link><pubDate>Sat, 10 May 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/work/2025-05-10-effective-objective-c%E6%80%BB%E7%BB%93/</guid><description>书是挺好的，但是翻译有的时候翻译真的有点烂，这里写一下我学习过程中，对例子解析一下。
6 了解属性的概念 这里引出OC和C++是不一样的，C++是使用offset的形式找到对应的数据变量，但是这样可能因为在不同的DLL导致起定义出错而crash，OC中将实例变量交给类对象管理，然后在运行期查找，不直接在编译期确定，可以避免上述的crash。甚至可以在运行期加入成员。
7 在对象内部尽量直接访问实例变量 我写代码的时候，经常有以下问题，一段代码中可以使用self.xxx或者_xxx进行访问，其中使用self.xxx可以使用懒加载，但是这里好像更推荐使用直接访问实例变量，也就是_xx这样，原因如下：
不会触发信息派发，那么就不会走msg_Send那一套，那么速度就会快一些 如果直接访问实例变量，那么就不会触发KVO（也就是键值观察）？ 但是有时候可能使用懒加载，那么这时候可能就需要self.xxxx了，所以就有一个折中，如果是在写入的话，那么就通过设置方法self.xxx来做，如果是读取，那么就直接访问。 12 理解动态转发 这篇讲得不错，其中的代码样例。
先看自己能不能解决，往自己对象里面加入方法，然后再跑一遍消息转发 自己不能解决，就让别的对象解决，看其他对象能不能能处理，比如说这个self的一些子类可能会处理这个self的方法 forwardingInvocation直接兜底，要么吃掉，要么转发其他对象，要么换成其他消息，如果怎么都不行最后直接doesNotRecognizeSelector报错。 17 实现description方法 顾名思义，主要是用于调试用的，在NSLog等控制台中进行调试，
带上对象的地址 带上对象的属性</description></item><item><title>iOS Runtime</title><link>https://liuzechen.top/work/2025-03-24-oc-runtime/</link><pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><guid>https://liuzechen.top/work/2025-03-24-oc-runtime/</guid><description>之前学了一下Objective-C的Runtime,发现学的不是那么深刻，所以这里写一篇文章，算是边写边学了。
概念 OC中加入了很多新的概念，其中主要好似有instace object和class object和meta object，主要是有以下区别，
instace object(实例对象)：instance示例对象是通过alloc出来的对象，每次使用alloc都会产生新的instance对象。 class对象(类对象)：对于每一个类，内存中有且只有一个类对象。 meta-class(元类对象)：对于每一个类来说，内存中有且只有一个类对象 这里说是对象，其实是因为oc everything is object，所以这里抽象成对象了，如果是C++，那么其实就是类，零成本抽象，其实没有那么多区别
对于上述对象中存储的东西，有以下区别。
实例对象（instance object） isa指针：指向的是类对象 对象中的成员变量 类对象（class object） isa指针：指向的是元类对象 superClass指针：指向的是他的父类，是类对象的父亲，如果到顶了，就是nil 类的属性信息（@property），类的对象方法信息（method &amp;lsquo;-&amp;lsquo;开头的方法）,类的协议信息（protocol）和类的成员变量信息（ivar）等。 元类（meta object） isa指针 superClass指针：指向他的父类，也就是元类对象的父亲，不同的是，如果到顶了，那么这里指向的是基类的class 类的方法信息（也就是+开头的方法） 以下是对象的相关关系
消息发送 OC中的调用方法是在Runtime运行期展开的，而不是像C/C++一样在编译期就确定了，所以与C++一样调到某一个地址就可以，大致的消息转发流程如下
先通过isa指针找到对应的类对象，或者是找到对应的meta-class 如如果是实例对象（instance object）调用，那么就找到对应的类对象（class object），如果是类方法调用，先找到对应的元对象（meta-class object） 如果当前找到了，那么就直接执行对应的方法就行了 如果没有找到，那么就通过类对象或者实例对象的superClass指针往上找，就是沿着他的父类找，一直往上找 如果最终找不到，那么就会Crash(当然，也会有补救错误) 这里有一点不同的是，注意到meta-class的superClass指针指向的是基类的类对象，那么这时候还是往基类的类对象找一下，调用一下，如果找不到，就crash。 补救方法 待补充</description></item></channel></rss>