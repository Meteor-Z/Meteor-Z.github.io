<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>iOS Runtime | Meteor-Z个人播客</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github.min.css rel=stylesheet></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>关于</a></li><li><a href=/work>工作笔记</a></li><li><a href=/posts/>随笔笔记</a></li><li><a href=/categories/>分类</a></li><li><a href=/tags/>标签</a></li><li><a href=/summarize/>总结</a></li><li><a href=/tips/>Tips</a></li><li><a href=/index.xml>订阅</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>iOS Runtime</span></h1><h2 class=author>Meteor-Z</h2><h2 class=date>2025/03/23</h2><p class=terms>Categories: <a href=/categories/ios>iOS</a>
Tags: <a href=/tags/runtime>Runtime</a> <a href=/tags/ios>iOS</a></p></div><main><p>之前学了一下Objective-C的Runtime,发现学的不是那么深刻，所以这里写一篇文章，算是边写边学了。</p><h2 id=概念>概念</h2><p>OC中加入了很多新的概念，其中主要好似有instace object和class object和meta object，主要是有以下区别，</p><ul><li>instace object(实例对象)：instance示例对象是通过alloc出来的对象，每次使用alloc都会产生新的instance对象。</li><li>class对象(类对象)：对于每一个类，内存中有且只有一个类对象。</li><li>meta-class(元类对象)：对于每一个类来说，内存中有且只有一个类对象</li></ul><p>这里说是对象，其实是因为oc everything is object，所以这里抽象成对象了，如果是C++，那么其实就是类，零成本抽象，其实没有那么多区别</p><p>对于上述对象中存储的东西，有以下区别。</p><ul><li>实例对象（instance object）<ul><li>isa指针：指向的是类对象</li><li>对象中的成员变量</li></ul></li><li>类对象（class object）<ul><li>isa指针：指向的是元类对象</li><li>superClass指针：指向的是他的父类，是类对象的父亲，如果到顶了，就是nil</li><li>类的属性信息（@property），类的对象方法信息（method &lsquo;-&lsquo;开头的方法）,类的协议信息（protocol）和类的成员变量信息（ivar）等。</li></ul></li><li>元类（meta object）<ul><li>isa指针</li><li>superClass指针：指向他的父类，也就是元类对象的父亲，不同的是，如果到顶了，那么这里指向的是基类的class</li><li>类的方法信息（也就是+开头的方法）</li></ul></li></ul><p>以下是对象的相关关系</p><ul><li><img src=OC-Runtime.png alt=OC-Runtime></li><li><img src=OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8.png alt=OC对象的存储></li></ul><h2 id=消息发送>消息发送</h2><p>OC中的调用方法是在Runtime运行期展开的，而不是像C/C++一样在编译期就确定了，所以与C++一样调到某一个地址就可以，大致的消息转发流程如下</p><ol><li>先通过isa指针找到对应的类对象，或者是找到对应的meta-class<ol><li>如如果是实例对象（instance object）调用，那么就找到对应的类对象（class object），如果是类方法调用，先找到对应的元对象（meta-class object）</li></ol></li><li>如果当前找到了，那么就直接执行对应的方法就行了</li><li>如果没有找到，那么就通过类对象或者实例对象的superClass指针往上找，就是沿着他的父类找，一直往上找</li><li>如果最终找不到，那么就会Crash(当然，也会有补救错误)<ol><li>这里有一点不同的是，注意到meta-class的superClass指针指向的是基类的类对象，那么这时候还是往基类的类对象找一下，调用一下，如果找不到，就crash。</li></ol></li></ol><h3 id=补救方法>补救方法</h3><p>待补充</p></main><footer><script src=//cdn.jsdelivr.net/combine/npm/katex/dist/katex.min.js,npm/katex/dist/contrib/auto-render.min.js,npm/@xiee/utils/js/render-katex.js defer></script>
<script src=//cdn.jsdelivr.net/npm/@xiee/utils/js/center-img.min.js defer></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/languages/r.min.js></script>
<script>hljs.configure({languages:[]}),hljs.initHighlightingOnLoad()</script><hr><a href=/change-log>ChangeLog</a><br>© <a href=https://github.com/Meteor-Z>Liu Zechen</a> 2022 &ndash; 2025 | All rights reserved.</footer></body></html>